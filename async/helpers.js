//Create a Promise that resolves after ms time
let timer = function (ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
};

/* --- */
//Repeatedly generate a number starting
//from 0 after a random amount of time
let source = async function* () {
  let i = 0;
  while (true) {
    await timer(Math.random() * 1000);
    yield i++;
  }
};

/* --- */
/*var source = function*() {
  var i = 0;
  while(true) {
    yield timer(Math.random() * 1000)
      .then(() => i++);
  }
};*/

/* --- */
//Tie everything together
var run = async function () {
  let stream = source();
  for await (let n of stream) {
    console.log(n);
  }
};

//run();
//=> 0
//=> 1
//=> 2
//=> 3
//...

/* --- */
//Return a new async iterator that applies a
//transform to the values from another async generator
var map = async function* (stream, transform) {
  for await (let n of stream) {
    yield transform(n);
  }
};

/* --- */
//Tie everything together
/* var run = async function() {
   var stream = source();
+   //Square values generated by source() as they arrive
+  stream = map(stream, n => n * n);
   for await (let n of stream) {
     console.log(n);
   }
 };*/

/* --- */
//=> 0
//=> 1
//=> 4
//=> 9
//...

/* --- */
/*var ws = new WebSocket('ws://localhost:3000/');
ws.addEventListener('message', event => {
  console.log(event.data);
});
*/
/* --- */
//Tie everything together
/*var run = async () => {
  var ws = new WebSocket('ws://localhost:3000/');
  for await (let message of ws) {
    console.log(message);
  }
};
*/
/* --- */
//Add an async iterator to all WebSockets
WebSocket.prototype[Symbol.asyncIterator] = async function* () {
  while (this.readyState !== 3) {
    yield (await oncePromise(this, 'message')).data;
  }
};

/* --- */
//Generate a Promise that listens only once for an event
var oncePromise = (emitter, event) => new Promise((resolve) => {
  var handler = (...args) => {
    emitter.removeEventListener(event, handler);
    resolve(...args);
  };
  emitter.addEventListener(event, handler);
});

/* --- */
//run();
//=> "hello"
//=> "sandwich"
//=> "otters"
//...

/* --- */
//Tie everything together
var run = async () => {
  let i = 0;
  let clicks = streamify('click', document.querySelector('body'));

  clicks = filter(clicks, (e) => e.target.matches('a'));
  clicks = distinct(clicks, (e) => e.target);
  clicks = map(clicks, (e) => [i++, e]);
  clicks = throttle(clicks, 500);

  subscribe(clicks, ([id, click]) => {
    console.log(id);
    console.log(click);
    click.preventDefault();
  });
};

//run();

/* --- */
//Turn any event emitter into a stream
var streamify = async function* (event, element) {
  while (true) {
    yield await oncePromise(element, event);
  }
};

/* --- */
//Only pass along events that meet a condition
var filter = async function* (stream, test) {
  for await (let event of stream) {
    if (test(event)) {
      yield event;
    }
  }
};

/* --- */
//Transform every event of the stream
var map = async function* (stream, transform) {
  for await (let event of stream) {
    yield transform(event);
  }
};

/* --- */
let identity = (e) => e;

//Only pass along events that differ from the last one
var distinct = async function* (stream, extract = identity) {
  let lastVal;
  let thisVal;
  for await (let event of stream) {
    thisVal = extract(event);
    if (thisVal !== lastVal) {
      lastVal = thisVal;
      yield event;
    }
  }
};

/* --- */
//Only pass along event if some time has passed since the last one
var throttle = async function* (stream, delay) {
  let lastTime;
  let thisTime;
  for await (let event of stream) {
    thisTime = new Date().getTime();
    if (!lastTime || thisTime - lastTime > delay) {
      lastTime = thisTime;
      yield event;
    }
  }
};

/* --- */
//Invoke a callback every time an event arrives
var subscribe = async (stream, callback) => {
  for await (let event of stream) {
    callback(event);
  }
};

/* --- */
/*var streamify = async function*(event, element) {
  element.addEventListener(event, e => {
     //This doesn't work because yield is being
     //called from inside another function.
    yield e;
  });
};*/
